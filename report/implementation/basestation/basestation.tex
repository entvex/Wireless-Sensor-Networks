\section{Base station}\label{sc:basestation}

The base station is master node in our setup. It is responsible for three import tasks: Initiating data requests, decide if the runner is out of range and keep track of past events. Figure \ref{fig:tohopornotarqsequence} shows the overall flow of data, but we shall examine the more detailed parts here.

\noindent The main control loop is started by a timer every $s$ second. It asserts if the runner is deemed out of range by calling a function and uses the feedback (either true or false) to increase an error counter that is used to change destination node. In other words, when a certain number of errors have occurred on the current link, we change request destination (from directly to relaying or vice versa). Listing \ref{lst:basestation1} is an example.
\noindent
\begin{minipage}[t]{0.95\linewidth}
	\begin{lstlisting}[language=Python, numbers=none, caption=XXX, label={lst:basestation1}]
Timer0.fired() {
	if out of range and link is direct {
		if the error count is below max
			use_next_destination
		else
			increase_error_count
	}
	if link is direct
		send_a_message_direct
	if link is relay to node north
		send_a_message_to_north
	if link is relay to node south
		send_a-message_to_south
}
	\end{lstlisting}
\end{minipage}

\noindent Next is how the base station determines if the runner is out range. When new replies are received directly from the runner (it starts in range) we save the RSSI\footnote{RSSI is a scalar register value on the CC2420 radio calculated from the RF input power in dBm.} value in a FIFO queue with a length of 10. In such a queue, new data is inserted at back and taken out from the front. This means that the latest RSSI value of the runner is the back entry, with $n=0,1,2 ... 8$ being previous positions. Our algorithm takes a mean of these and multiplies it with a weighted score. If the latest position is lower than the mean, it is added to the weighted mean of the previous positions. If it is greater the average is then subtracted from it. The result constitutes a new estimated position of the runner. Listing \ref{lst:basestation2} is an example.

\noindent
\begin{minipage}[t]{0.95\linewidth}
\begin{lstlisting}[language=Python, numbers=none, caption=XXX, label={lst:basestation2}]
bool isOutOfRange {
	if current size of queue is not max
		return
	for(i = 0; i < queue_size; i++)
		previousPos += queue_part[i]
		
	lastPos = queue_back_entry
	mean = previousPos/queue_size
	
	if lastPos is less than mean
		newPos = (lastPos*1)+(mean*0.1);
	else
		newPos = (lastPos*1)-(mean*0.1);
	
	if(newPos is larger than threshold)
		return true;
	return false;
}
\end{lstlisting}
\end{minipage}

\noindent The weights used can be changed to put more empathize on the previous positions or more on the latest.